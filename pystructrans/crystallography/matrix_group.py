from ..general_imports import *
from itertools import chain
from ..__util__ import divisors, rotation
from ..util import BST, HashArray

# square group
SQUARE_GROUP = np.array([
    # identity
    [[1, 0], [0, 1]],
    # 90 rotations
    [[0, -1], [1, 0]],
    [[0, 1], [-1, 0]],
    # 180 rotation,
    [[-1, 0], [0, -1]]
])
SQUARE_GROUP_EXT = np.array([
    # mirror along x
    [[1, 0], [0, -1]],
    # mirror along y
    [[-1, 0], [0, 1]],
    # mirror along (1,1)
    [[0, 1], [1, 0]],
    # mirror along (-1,1)
    [[0, -1], [-1, 0]]
])
SQUARE_GROUP_EXT = np.append(SQUARE_GROUP, SQUARE_GROUP_EXT, axis=0)

class MatrixGroup():
    """
    Matrix representation of a group, in particular point groups and Laue groups.

    ``matrices`` should be a datatype that can be converted to a 3D :py:class:`numpy.ndarray`
    and the last two dimensions define a square matrix.
    """

    def __init__(self, matrices):
        self.__mtable = self.isgroup(matrices)
        if self.__mtable is False:
            raise ValueError("input does not form a group")
        self.__mats = matrices

    def multable(self):
        """
        :return: multiplication table
        :rtype: :py:class:`numpy.ndarray`
        """
        return self.__mtable

    def matrices(self):
        """
        :return: all the elements
        :rtype: :py:class:`numpy.ndarray`
        """
        return self.__mats

    def order(self):
        """
        :return: the group order
        :rtype: integer
        """
        return len(self.__mats)

    def isabelian(self):
        """
        :return: if the group is abelian
        :rtype: boolean
        """
        N = self.order()
        for i in xrange(N):
            for j in xrange(i + 1, N):
                if self.__mtable[i, j] != self.__mtable[j, i]:
                    return False
        return True

    def hassubgroup(self, g):
        """
        :param g: another MatrixGroup
        :return: if ``g`` is a subgroup of the invoking group
        :rtype: boolean
        :raises ValueError: if `g` is not an instance of :py:class:`pystructrans.MatrixGroup`

        """
        if not isinstance(g, MatrixGroup):
            raise ValueError("input must be a MatrixGroup")

        if g.order() not in divisors(self.order()):
            return False

        for m1 in g.matrices():
            found = False
            for m2 in self.matrices():
                if nanmax(np.abs(m1 - m2)) < 1.0E-12:
                    found = True
                    break
            if not found:
                return False

        return True

    @classmethod
    def generategroup(cls, generators):
        """
        generate a MatrixGroup, by provided genrators and matrix multiplication.
        The identity element must be the identity matrix.

        :param: a list of square matrices of the same shape
        :return: the generated group
        :rtype: :py:class:`MatrixGroup`
        :raises ValueError: invalid input, or inconsistent shape
        """
        try:
            generators = np.array(generators)
        except:
            raise ValueError("invalid input")

        shape = generators[0].shape

        E = np.eye(shape[0])
        matrices = BST(HashArray(E))

        def merge(matrices, cycle):
            """merge cycle into cycles"""
            newmatrices = None
            for m in cycle:
                # add to matrices
                if not HashArray(m) in matrices:
                    newmatrices = BST(HashArray(m))
                    for n in matrices:
                        r = HashArray(np.round(m.dot(n.array), 10))
                        if not (r in matrices or r in newmatrices):
                            newmatrices.add(r)
                        r = HashArray(np.round(n.array.dot(m), 10))
                        if not (r in matrices or r in newmatrices):
                            newmatrices.add(r)
                for n in newmatrices:
                    oldsize = matrices.size
                    matrices.add(n)
                    newsize = matrices.size
                    if newsize == oldsize:
                        print(n in matrices)
            return matrices

        for g in generators:
            if g.shape != shape:
                raise TypeError("not all the matrices are in the same shape")
            # cyclic group generated by g
            cycle = [g]
            while not np.max(np.abs(cycle[-1] - E)) < 1.e-6:
                cycle.append(cycle[-1].dot(g))
            # merge it into result
            matrices = merge(matrices, cycle)
        return np.array([m.array for m in matrices])


    @classmethod
    def isgroup(cls, matrices):
        """
        check is a list of `square matrices` form a group

        :param matrices:  anything can be converted in to a [`M` x `N` x `N`] :py:class:`numpy.ndarray`
        :return: return the multiplication table if is a group, otherwise return False
        :rtype: boolean or 2D :py:class:`numpy.ndarray`
        """
        try:
            mats = np.round(np.array(matrices), 6)
        except Exception:
            logging.debug("not array")
            return False
        shape = mats.shape
        if len(shape) != 3 or shape[1] != shape[2]:
            logging.debug("wrong shape")
            return False

        dim = shape[1]
        hashmap = {}
        # existance of identity
        id_exist = False
        for i, m in enumerate(mats):
            if tuple(m.flatten()) in hashmap:
                logging.debug("duplicate")
                logging.debug("i = {:d}, md = {:s}".format(i, str(m)))
                return False
            hashmap[tuple(m.flatten())] = i
            if nanmax(np.abs(m - np.eye(dim))) < 1.0e-10:
                id_exist = True
        if not id_exist:
            logging.debug("no id")
            for m in matrices:
                logging.debug(m)
            return False

        N = len(mats)

        def ingroup(M):
            for i, m in enumerate(mats):
                if nanmax(np.abs(M - m)) < 1.0e-5:
                    return i
            return -1

        mtable = np.empty((N, N), dtype='int')
        for i in xrange(N):
            for j in xrange(N):
                m = np.round(mats[i].dot(mats[j]), 6)
                idx = ingroup(m)
                if idx > -1:
                    mtable[i, j] = idx
                else:
                    logging.debug("false multable")
                    logging.debug("mi = {:s}".format(str(mats[i])))
                    logging.debug("mj = {:s}".format(str(mats[j])))
                    logging.debug("m = {:s}".format(str(m)))
                    return False

        return mtable

cubic_Laue_group_mats = np.array([
    # identity
    [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
    # two fold rotations
    [[1, 0, 0], [0, -1, 0], [0, 0, -1]],  # [100]
    [[-1, 0, 0], [0, 1, 0], [0, 0, -1]],  # [010]
    [[-1, 0, 0], [0, -1, 0], [0, 0, 1]],  # [001]
    [[0, 1, 0], [1, 0, 0], [0, 0, -1]],  # [110]
    [[0, -1, 0], [-1, 0, 0], [0, 0, -1]],  # [1-10]
    [[0, 0, 1], [0, -1, 0], [1, 0, 0]],  # [101]
    [[0, 0, -1], [0, -1, 0], [-1, 0, 0]],  # [10-1]
    [[-1, 0, 0], [0, 0, 1], [0, 1, 0]],  # [011]
    [[-1, 0, 0], [0, 0, -1], [0, -1, 0]],  # [01-1]
    # four fold rotations about [100]
    [[1, 0, 0], [0, 0, -1], [0, 1, 0]],
    [[1, 0, 0], [0, 0, 1], [0, -1, 0]],
    # four fold rotations about [010]
    [[0, 0, 1], [0, 1, 0], [-1, 0, 0]],
    [[0, 0, -1], [0, 1, 0], [1, 0, 0]],
    # four fold rotations about [001]
    [[0, -1, 0], [1, 0, 0], [0, 0, 1]],
    [[0, 1, 0], [-1, 0, 0], [0, 0, 1]],
    # three-fold rotations about [111]
    [[0, 1, 0], [0, 0, 1], [1, 0, 0]],
    [[0, 0, 1], [1, 0, 0], [0, 1, 0]],
    # three-fold rotations about [-111]
    [[0, 0, -1], [-1, 0, 0], [0, 1, 0]],
    [[0, -1, 0], [0, 0, 1], [-1, 0, 0]],
    # three-fold rotations about [-1-11]
    [[0, 1, 0], [0, 0, -1], [-1, 0, 0]],
    [[0, 0, -1], [1, 0, 0], [0, -1, 0]],
    # three-fold rotations about [1-11]
    [[0, 0, 1], [-1, 0, 0], [0, -1, 0]],
    [[0, -1, 0], [0, 0, -1], [1, 0, 0]]
])
CUBIC_LAUE_GROUP = MatrixGroup(cubic_Laue_group_mats)

# this is not really a group,
# because it contains no identity.
# Also it does not contain the 2 fold rotation about z-axis.
__C1 = np.cos(np.pi / 3.0)
__S1 = np.sin(np.pi / 3.0)
hex_Laue_group_mats = np.array([
    # identity
    [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
    # two fold rotations
    [[1, 0, 0], [0, -1, 0], [0, 0, -1]],  # [100]
    [[-1, 0, 0], [0, 1, 0], [0, 0, -1]],  # [010]
    [[-1, 0, 0], [0, -1, 0], [0, 0, 1]],  # [001]
    [[__C1, -__S1, 0], [__S1, __C1, 0],  [0, 0, 1]],
    [[__C1, __S1, 0], [-__S1, __C1, 0],  [0, 0, 1]],
    [[-__C1, -__S1, 0], [__S1, -__C1, 0],  [0, 0, 1]],
    [[-__C1, __S1, 0], [-__S1, -__C1, 0],  [0, 0, 1]],
    [[__C1, -__S1, 0], [-__S1, -__C1, 0],  [0, 0, -1]],
    [[__C1, __S1, 0], [__S1, -__C1, 0],  [0, 0, -1]],
    [[-__C1, -__S1, 0], [-__S1, __C1, 0],  [0, 0, -1]],
    [[-__C1, __S1, 0], [__S1, __C1, 0],  [0, 0, -1]]
])
HEX_LAUE_GROUP = MatrixGroup(hex_Laue_group_mats)
